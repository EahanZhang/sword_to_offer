package optimize_time_and_space_efficiency._43一到n整数中1出现的次数;

/**
 * Created By sunshine on 2018/8/7
 */

/**
 * 题目：
 *  求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
 *  为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
 *  ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
 *
 * 思路：
 *  假设N = abcde, 其中abcde分别为十进制中各位上的数字。
 *  如果要计算百位上1出现的次数， 它受到三个方面的影响： 百位上的数字， 百位以下（低位）的数字， 百位以上（高位）的数字。
 *  1. 如果百位数字上为0， 百位上出现1的次数由高位决定。 假设N为12013， 则可以知道百位出现1的情况可能是，100-199, 1100-1199
 *  2100-2199, ..., 11100-11199, 一共12000个。 可以看出是由高位(12)决定， 并且等于高位数字*10.
 *  2. 如果百位数字上为1， 则不仅受高位决定， 还受低位决定。 假设N为12113， 则其受高位影响的数字为100-199,1100-1199,...,
 *  11100-11199, 一共1200个。 同时还受低位影响，12100-12113，一共14个， 低位数字+1(13 + 1)。
 *  3. 如果百位数字上大于1，则仅受高位影响，如12213，则百位上出现1 的情况是100-199, 1100-1199, ..., 11100-11199, 12100-12199, 一共1300个
 *  等于(高位数字+1)*10
 */

public class NumberOf1Between1AndN {
    public int numberOf1Between1AndN(int n) {
        int count = 0;
        int i = 1; // 当前位
        int current = 0, after = 0, before = 0;

        while (n / i != 0) {
            current = (n / i) % 10; // 当前位数字
            before = n / (i * 10); // 高位数字
            after = n % i;

            if (current == 0) {
                count += before * i;
            } else if (current == 1){
                count += before * i + after + 1;
            } else {
                count += (before + 1) * i;
            }

            // 左移一位
            i *= 10;
        }

        return count;
    }
}
